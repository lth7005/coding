'''
#퍼즐 5번째 "제발 유리 구슬이 깨지길"
#문제 : 128층인 상하이 타워에서 유리구슬을 떨어뜨렸을 때 깨지지 않는 가장 높은 층을 찾아내기
#문제 설명: 
유리구슬의 단단한 정도를 알아내기 위해 
어떤 건물에서 유리구슬을 떨어뜨려 깨지지 않는 가장 높은 층수를 찾으려고 한다.
어떤 층에서 깨지지 않으면 그 아래의 층수에서는 절대 깨지지 않는다.
어떤 층에서 깨지면 그 위의 층수에서는 항상 깨진다.
그리고 유리구슬은 한 번 깨지면 다시 사용할 수 없다.
최대 층수를 알아야하기 때문에, 만약 100층인 건물의 50층에서 떨어뜨려서 깨진다면
51층부터 100층까지 깨진다는 것은 알 수 있지만 그 아래 층수 중에서 몇 층까지 견디는지를 알 수가 없다. 
가장 정확한 방법은 1층부터 한 층씩 던져보는 방법이다.
여기 구슬이 두 개 있다. 어떻게 하면 좀 더 적게 던져서 유리구슬의 강도를 알아낼 수 있을까?!
#(참고사항 : break구문, 진수표현)
'''

'''
풀이과정(구슬이 두 개일 때)
1.
100층이라고 하고 첫번째 구슬을 중간인 50층에서 떨어뜨리면 최악의 경우 50번 던져야한다.
직관적으로 중간을 선택했지만 문제에서는 더 적은 횟수가 가능하다고 한다. 
문제에서는 21회로도 가능하고 그보다 더 적은 횟수를 던져서 확인할수 있다고 한다. 그게 가능한가? :(
문제에서 중간을 선택하는 것보다 더 적은 횟수가 가능하다고 하니
역시 직관적으로 구슬의 개수만큼 주어진 건물의 층수를 일정한 간격으로 잘라본다.
2.
(  )-구슬1-(  )-구슬2-(  ) 처럼 구슬이 2개이면 건물을 3등분할 수 있다.
대략 30층에서 첫번째 구슬을 던진다. 깨지면 최악 30번 던져야 한다. 
깨지지 않으면 남은 70층을 다시 3등분 한다. 여기서 남은 구슬은 2개다.
즉, 이것은 "3등분했을 때 두 가지 경우 중에서 하나는 최악 30번이고 
다른 하나는 최악 +1번에" 라는 조건을 달고 있는 상태로 다시 처음 문제를 마주하는 것과 같다.
70층과 구슬 2개가 주어진 상태에서 던진 횟수는 단지 +1만 된 상태이다.
실제로는 31층부터 100층이지만 그냥 계산하기 쉽게 1층부터 70층이라고 간주하자.
70층을 23층씩 3등분 할 수 있으니까 대략 25층 쯤에서 던진다. 
깨지면 최악 +1+25 로 약 25회이다. 안깨지면 다시 남은 층수인 약 45층을 3등분 한다. 15층이다.
15층에서 깨지면 +1+1+15회이고 안깨지면 남은 30층에서 다시 3등분.. 계속 반복이다.
일정한 규칙이 보이는 것 같다. 계속 반복되도 최악은 30회를 넘지 않는다. 뭔가 더 줄여질 것 같다.
3.
(위의 방법을 생각하기 전에 그보다 먼저 이 방법을 시도해보았다. 
중간을 선택하는 것보다 더 적은 횟수가 가능하다고 하니,
100층에서 50층이 아닌 그냥 40층을 선택해본다. 깨지면 최악 40번, 안깨지면 남은 60층과 구슬 2개.
60층 절반 나눠서 30층에서 던지고 깨지면 최악 약30회. 40층을 선택해도 된다!
이제는 40층이 아니라 30층으로 선택해보자. 깨지면 30회, 안깨지면 70/2=45회
하지만 이 방법은 규칙적이지 않다. 처음 100층에서 임의로 30층을 선택하고 남은 층수 절반.
프로그래밍? 알고리즘?은 규칙적이고 반복적인 과정을 컴퓨터에게 맞기는 일이라고 책에서 본 것 같다.
그래서 처음 100층에서 30층을 선택했으니 남은 층수도 그에 맞게 1/3로 선택해야할 것 같은 느낌이 들었다.)
4.
3등분하는 방법을 다시 보자. 구슬이 2개여서 3등분을 했지만 반복적인 규칙을 보니 구슬의 개수와 
상관없이 4등분 5등분 ... 더 여러번 나눠도 될 것 같다. 10층씩 나눠본다.
유리구슬 2개가 있다. 100층인 건물이 있다. 10층에서 던진다. 깨지면 최악 10회. (최악 10회?!)
안깨지면 다시 20층으로 건너뛴다. (20층에서는 10층에서 던진 횟수 +1을 계산해야함) 20층에서
깨지면 역시 최악 약 10회. 안깨지면 다시 30층으로 건너뛴다. ... 이것이 더 간편해보인다.
다만 건너뛸 수록 그리고 층수가 100층 200층 1000층 처럼 증가할 수록 건너뛰는 횟수도 고려해야 한다.
5.
정확하게 계산해보자.
128층 건물, 구슬 2개가 있다.
10층 던진다. 깨지면 10회. 
아니면 +1 20층 던진다. 깨지면 10+1회. 
아니면 +2 30층 던진다. 깨지면 10+2회. 
~~~
아니면 +11 120층 던진다. 깨지면 10+11회. = 21회 
안깨지면 121층부터 128층까지 8회니까 8+11회. = 19회
즉, 최악의 경우 21회.
21회가 나왔다!!
6.
그런데 21회보다 더 적은 횟수가 가능하다고 한다.
마지막 19회와 21회를 서로 맞추면 가능할지도?! 반복되는 10회를 9회로? 즉, 9층씩 나누면?
9층 던지고 깨지면 9회.
아니면 +1 18층 던지고 깨지면 9+1회.
아니면 +2 ~~~ (128 = 9*14 +2 이니까 마지막에 2층이 남는데...)
128은 2**7 이니까 128 = 8*16 + 0 뭔가 될 것 같다.
7.
8층 던진다. 깨지면 8회.
아니면 +1 16층 던진다. 깨지면 8+1회
~~~
아니면 +15 120층 던진다. 깨지면 8+15회.
음... 이게 아니구나.
8.
x층으로 건너뛰면 마지막은 최악의 횟수 = x + (주어진 건물 층수 // x) -1
9.
x층으로 건너뛸 때 주어진 건물 층수가 x로 나누어 떨어질 때는?
10.
128층 건물을 10층 간격으로 진행하다가 마지막 110에서는 남은 층수가 18층이다.
곧바로 10층을 건너뛰어 8층을 남겼는데, 남은 18층을 2등분 해서 9층씩 건너뛴다면? 
11.
'건너뛴다' : 
5층 건물에 구슬이 1개이면 최악은 5회. 1층부터 하나씩 올라간다.
구슬이 2개이고 1칸만 건너뛴다고 하면 즉, 가장 처음 1층을 패스하고 2층 검사, 3층 패스 4층 검사.
이것은 건너뛰는 최소한?의 방법. 
다시말해 2층 간격으로 검사하는 것이 최소한의 방법. ...??
12.
x층 간격과 y층(=10) 건물일 때 최악 획수 z라면
z =  ( y // x ) + x -1
x = 2, z = 2 + 5 -1 = 6
x = 3, z = 3 + 3 -1 = 5 
x = 4, z = 4 + 2 -1 = 5
x = 5, z = 5
x = 6, z = 6
13.
128층, x=10 z=21
x=8 z=23 
x=9 z=22  (128 = 9*13 +r)
x=10 z=21 (128 = 10*12 +r)
x=11 z=21 (128 = 11*11 +r)
x=12 z=21 (128 = 12*10 +r)
x=13 z=21 (128 = 13*9 +r)
x=14 z=22
14.
(나눗셈으로 계산해서) y를 두 수의 곱으로 나타낼 때 두 수의 차가 가장 작은 경우를 골라낸다.
두 수 중에서 하나는 몫, 하나는 나누는 숫자? 
나머지 r은 양수. 3*4-1 = 11, 4*4-1 = 15 이지만 이때 음수이면 두 수를 사용하지 않기로.
나눗셈의 결과를 이용했으니까. 나눗셈은 몫을 더 크게해서 나머지를 음수로 하지 않으니까. ?!
15.
10층 간격과 11층 간격은 둘 모두 110에서 같은 최악의 수를 나타내고 같은 남은 층수를 나타낸다.
남은 층수 18층.
z = (y // x) + x -1 이 공식과 x,y 두 수의 차가 가장 적은 경우를 사용하면
18층 = 4*4 +2
z = 4 + 4 -1 = 7 !!!!!
16.
그러면.
110층까지 10층 또는 11층 간격으로 진행했으니 검사횟수는 모두...
그럼 11층 간격으로 해야 검사 횟수가 1번 줄어드니
11층 간격으로 110층까지 검사횟수는 모두 10회. (주의! '건너띄기'와 '검사'는 서로 다름!!)  
(여기서 11은 128을 나누는 숫자에 해당한다. 몫도 11이다. 
이것은 128을 나눗셈에서 나누는 숫자와 몫, 두 수의 차가 가장 작은 경우라는 조건을 만족한다.)
남은 층수 18층
18층. 구슬 2개. 4층 간격. 최악의 수 7회.
따라서 유리구슬을 던지는 최소한의 최악횟수는 17회. !!!!!!!!!!!!!!!!!!!!
17.
16번은 틀림. 
11층 간격으로 110층에서 깨지면 z는 
이전 검사 횟수 10회 + 남은 층수인 99층 이후부터 110층 이전까지 검사해야함.
따라서 10 + 10 = 20회
안깨져도 이전검사횟수는 11회가 되고 남은 층수는 18층이지만
이미 최악의 수는 20회를 넘었음.
18.
최초 128층이 주어지고, 128 = 11*11 +7 에서 11층 간격으로 검사하기로 했다.
11층을 검사하고 남은 117층에 대해서 다시 나눗셈 계산으로 117 = 11*10 +7 이므로 11로 하기로 한다.
이런 식으로 검사한 후 남은 층수에 대해서 매번 공식으로 어떤 간격을 검사할지 판단해야하는 것 아닐까?
19.
어떤 방법을 고민하든 그 방법에서 가장 최악의 횟수가 늘어나지 않고 작게 유지되는지 확인하면 된다.
20.
(아래 계산 과정에서 몇 가지 의문점이 있지만 일단 진행.
의문점은, 1.애초에 이 공식 자체가 주어진 층수를 어떤 간격으로 일정하게 나누었을 때를 전제로 만들어진 것. 그걸 이렇게 매 검사마다 다른 간격으로 써도 되는지.
2.공식에서 간격으로 정한 숫자는 117 = 11*10 +7 처럼 11이나 10 아무거나 써도 상관 없는지. 뒤에서 나누는 간격을 계속 빼줘야하는데..일단은 두 수 중 큰 수를 간격으로 정하기로.
3.큰 수와 작은 수 두 경우를 모두 직접 확인해볼 것.)
현재까지 검사한 횟수] 남은 층 = 간격 * 횟수 + 나머지, 남은 층 - 그 간격으로 검사할 층 = 그 간격으로 검사하면 남을 층 
(여기서 중요한 것은 콤마 뒤의 식에서 음수값(=앞의 식의 곱해지는 앞의 수). 이 값이 현재의 층에서 다음으로 검사해야할 층이 몇 층인지 알려주는 수.)
1]128=11*11+7, 128-11=117 
2]117=11*10+7, 117-11=106
3]106=10*10+6, 106-10=96
4]96=10*9+6, 96-10=86
5]86=9*9+5, 86-9=77
6]77=9*8+5, 77-9=68
7]68=8*8+4, 68-8=60
8]60=8*7+4, 60-8=52
9]52=7*7+3, 52-7=45
10]45=7*6+3, 45-7=38
11]38=6*6+2, 38-6=32
12]32=6*5+2, 32-6=26
13]26=5*5+1, 26-5=21
14]21=5*4+1, 21-5=16
15]16=4*4+0, 16-4=12
16]12=4*3+0, 12-4=8
17]8=4*2+0, 8-4=4
18]4=2*2+0, 4-2=2
19]2=2*1+0, 2-2=0
21.
20번의 방법이 적절한지 10층 건물로 최악의 횟수를 점검해보기로.
그리고 20번 이전의 방법(동일한 간격으로 계속 계산)과 비교해보기로.(22번에서)
10=3*3+1, 10-3=7
7=3*2+1, 7-3=4
4=2*2+0, 4-2=2
2=2*1+0, 2-2=0  
3층에서 검사. 깨지면 3회. 아니면 
6층에서 검사. 깨지면 3회+1. 아니면 
8층에서 검사. 깨지면 2회+2. 아니면 
10층에서 검사. 깨지면 2회+3. 아니면 +4회
22.
동일한 간격으로 계속 계산하면 문제는 마지막에 남은 나머지를 어떻게 검사할지이다.
10층 간격으로 검사를 했고 남은 층수가 8층이면
이 8층을 아무렇게나 절반 쯤에서 검사할 수는 없으니까...
이 8층 역시 공식을 대입해야할 것 같다. 
그런데 남은 8층을 3*2+2로 표현할 수 있어서 3층 간격으로 조사하는데
또 남은 5층이 문제다. 같은 방식으로 8층 이전의 18층, 28층 역시
10층 간격으로 하기에는 +1,2차이처럼 작은 차이라 괜찮을 것도 같다.
그런데 층수가 100만 1000만 억 단위로 높아진다면 어떨까.
23.
그래서 검사 후 남은 층수에 매번 그 공식을 적용하는 것이 적절해보인다.
그 공식의 의미를 다시 살펴보면,
구슬 2개가 있는 상태에서 주어진 층수를 몇층 간격으로 검사해야 최소한의 검사가 가능한지 알아내는 것.
일정한 간격으로 검사하는 것이 물론 위에서 살펴본 것처럼 정확하지는 않지만 최소한의 검사횟수에 근접한 것 같다.
이 이상 더 최소한의 검사횟수를 판단해내는 어떤 한번의 공식, 하나의 알고리즘은 찾기가 어려워보인다.
최소한의 검사횟수에 가까이 근접, 수렴하는 이 알고리즘을 남은 층수마다 계속 새롭게 써주면
그 오차도 줄어들 것이다. 이 방법이 최소값에 가장 수렴하는 방법인 것 같다.
한편 검사 후 남은 구슬이 2개이고 남은 층수가 있다면 그것은 역시 새롭게 주어진 구슬 2개와 건물이라고 볼 수 있다.
그래서 '어떤 한 번의 공식, 하나의 알고리즘'이라고 말했던 것은, 
검사를 어디서 해야 좋은지 현재 상태에서 바로 다음 위치, 그 하나의 위치를 알아내는 방법이라고 말할 수 있다.
그 논리, 규칙을 반복적으로 적용해서 다음, 그 다음, 또 그 다음을 예상하는 것.
24.
확인해볼 사항 = 수렴하는 공식이 적절한지.
원래 공식은 검사하는 간격이 항상 일정하다.
수렴하는 공식은 검사하는 간격이 점점 줄어든다. 
간격을 점점 줄이는 게 타당한지를 확인할 것. 그게 무슨 의미인지도.
25.
다시 이 문제의 요점을 살펴보자.
만들어낸 규칙, 공식, 알고리즘이 있다면 이것을 수행했을 때 발생하는 최악의 수를 확인한다.
그리고 그 최악의 수를 가장 작게 만들어주는 알고리즘을 구현해야한다.
3가지 방법이 있다. 100층을 
하나.10층 간격으로 항상 일정하게 조사하는 방법 = 10, 10, 10, ~ 간격
둘.10층 간격으로 시작해서 점점 늘어나게 조사하는 방법 = 10, 11, 12, ~ 간격
셋.10층 간격으로 시작해서 점점 줄어들게 조사하는 방법 = 10, 9, 8, ~ 간격
일정한 것과 줄어드는 것은 살펴보았으니 늘어나는 두번째를 살펴보기로. 그리고 이렇게 비교하는 이유는
최악의 수가 줄어드는게 어떤 의미인지 알아보기 위해서이다.
이 예시처럼 쉽게 생각해볼 수 있다. 
(쉬운 결론은 언제나 정확하고 구체적인 예시를 통해서 도달할 수 있는 것 같다.)
위의 3가지 예시에서 알고리즘을 수행한 결과로 최악의 수를 나열하면
하나. 10, 10+1, 10+2, ~ 이렇게 된다. 1씩 증가하는 이유는 이전에 검사한 횟수이기 때문이다.
둘. 10, 11+1, 12+2, ~ 이렇게 된다.
셋. 10, 9+1, 8+... 이것은... 실제 알고리즘의 정확한 간격은 이렇다.
11, 11, 10, 10, 9, 9, 8, ~ 그리고 결과는 다음과 같다.
11, 11+1, 10+2, 10+3, 9+4, 9+5, 8+6, ~ 이걸 다시 써보면
11, 12,   12,   13,   13,  14,  14, ~ 
이렇게 살펴본 결과, 놀라운 사실을 두 가지 발견했다.!!
첫 번째는 0으로 수렴하는 간격 알고리즘이 일정한 간격의 규칙보다 더 좋다는 것!
가장 작은 최악의 획수를 좀 더 오랫동안 유지시켜주는 결과를 보인다!
두 번째는 점점 간격이 늘어날 경우 간격이 일정할 때보다 매 시점마다 최악의 횟수가 훨씬 늘어난다는 것.
미리 예단해서 간격증가 규칙을 무시할 수도 있지만 섣부른 판단일 수도 있다.
간격이 늘어난 만큼 전체 실험하는 횟수는 일정할 때보다 줄어들기 때문이다. 
역시 직접 끝까지 진행시켜야 정확한 비교가 가능할 것 같다.
26.
100층 건물이고 10층 간격 시작한다.
먼저 일정한 경우의 결과는
10, 10+1, 10+2, ~ , 10+9 따라서 19회
그 다음 점점 늘어나는 경우의 결과는
10, 11+1, 12+2, ~ , 16+6 따라서 22회 (16간격으로 검사를 한 곳의 층수는 91층)
다음으로 점점 줄어드는 경우의 결과는 <-y = a*b + r 과 z = (y // x) +x -1 를 이용
(알고리즘에 따라 직접 하든 계산기로 하든 하나씩 결과를 확인할 수 있어야 한다.
실제로 하나씩 계산해보면 10, 10, 9, 9, 된다고 해서 그 이후도 두 개씩 계속 반복하지 않는다.
중간에 불규칙적인 것이 있다. 여기서 불규칙이란 말은 결과가 그렇다는 이야기.
결과가 규칙적이든 불규칙적이든 정해진 알고리즘에 따라 나온 결과이므로 크게 상관없어보인다.
중요한 것은 결과를 정해진 알고리즘으로 직접 구한 것인지 아니면 직관적으로 예측한 것인지이다.
실제로 해보면 그리고 계산 과정에서 산수가 틀리지 않았다면 최종 결과는 99층에서 이전회수 18회가 나온다.)
1+18 따라서 19회. 100층 건물에서는 일정한 간격 알고리즘과 동일한 값이다.
건물의 층수가 더 늘어난다면?
이것은 코딩으로 확인해야할 것 같다.
'''